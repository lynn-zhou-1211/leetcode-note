
## graph
1. 创建邻接表/邻接矩阵的方法，分别适用于什么场景
2. 拓扑排序流程 lc 210
   - 初始化邻接表和入度数组
   - 建图并计算入度
   - 将所有入度为0的节点加入队列
   - bfs，从队列中取出节点，遍历每个邻居并对邻居的入度--；如果入度为0，就入队
   - 比较处理过的节点数量和总数是否相等
3. 三色标记法 lc 207

   状态定义：
   * **0 (未搜索)**：节点还没有被访问过。
   * **1 (搜索中)**：节点在当前递归栈中（正在访问它的子节点），即**正在回溯的路径上**。
   * **2 (已完成)**：节点及其所有子节点都已访问完毕，已从递归栈弹出。
   
   如果在 DFS 过程中，你遇到了一个状态为 **1 (搜索中)** 的邻居节点，说明你绕了一圈回到了当前路径上的某个祖先节点，即**存在环**。

4. 并查集
   * **原理**：遍历每条边 `(u, v)`。
   * 在连接之前，先检查 `u` 和 `v` 是否已经属于同一个集合（即 `find(u) == find(v)`）。
   * 如果**是**，说明 `u` 和 `v` 之前已经通过其他路径连通了，现在又要直接连一条边，那么必然形成环。
   * 如果**不是**，则执行 `union(u, v)` 合并集合。

5. 查找环

   | 图类型 | 推荐方法 1 | 推荐方法 2 | 核心逻辑 |
   | --- | --- | --- | --- |
   | **有向图** (课程表) | **拓扑排序 (BFS)** | **DFS (三色标记)** | 遇到“正在访问”的节点即为环 |
   | **无向图** (网络连接) | **并查集 (Union-Find)** | **DFS (记录父节点)** | 两个节点已连通又加一条边即为环 |
